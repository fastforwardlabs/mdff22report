<!DOCTYPE html>
    <html lang="en">
      <head>
<meta charset="utf-8" />

<title>Inferring Concept Drift Without Labeled Data</title>
<meta name="description" content="An online research report on concept drift by Cloudera Fast Forward Labs." />

<meta property="og:title" content="Inferring Concept Drift Without Labeled Data" />
<meta property="og:description" content="An online research report on concept drift by Cloudera Fast Forward Labs." />
<meta property="og:image" content="https://concept-drift.fastforwardlabs.com/figures/ff22-cover-splash.png" />
<meta property="og:url" content="https://concept-drift.fastforwardlabs.com" />
<meta name="twitter:card" content="summary_large_image" />

<meta name="viewport" content="width=device-width" />
<link rel="icon" type="image/x-icon" href="favicon.ico" />

<style type="text/css">
    
  @font-face {
    font-family: 'Plex Mono';
    src: url('fonts/IBMPlexMono-Regular.woff2') format('woff2'),
      url('fonts/IBMPlexMono-Regular.woff') format('woff');
    font-weight: normal;
    font-style: normal;
  }
  @font-face {
    font-family: 'Plex Mono';
    src: url('fonts/IBMPlexMono-Italic.woff2') format('woff2'),
      url('fonts/IBMPlexMono-Italic.woff') format('woff');
    font-weight: normal;
    font-style: italic;
  }
  @font-face {
    font-family: 'Plex Sans';
    src: url('fonts/IBMPlexSans-Regular.woff2') format('woff2'),
      url('fonts/IBMPlexSans-Regular.woff') format('woff');
    font-weight: normal;
    font-style: normal;
  }
  @font-face {
    font-family: 'Plex Sans';
    src: url('fonts/IBMPlexSans-Italic.woff2') format('woff2'),
      url('fonts/IBMPlexSans-Italic.woff') format('woff');
    font-weight: normal;
    font-style: italic;
  }
  @font-face {
    font-family: 'Plex Sans';
    src: url('fonts/IBMPlexSans-Bold.woff2') format('woff2'),
      url('fonts/IBMPlexSans-Bold.woff') format('woff');
    font-weight: bold;
    font-style: normal;
  }
  @font-face {
    font-family: 'Plex Sans';
    src: url('fonts/IBMPlexSans-BoldItalic.woff2') format('woff2'),
      url('fonts/IBMPlexSans-BoldItalic.woff') format('woff');
    font-weight: bold;
    font-style: italic;
  }
  
    * {
      box-sizing: border-box;
    }
    html {
      background: #fff;
      font-family: "Plex Sans", serif, sans-serif;
      font-size: 17.5px;
      line-height: 28px;
    }
    body {
      margin: 0;
    }
    .content {
      max-width: 64ch;
      padding-left: 2ch;
      padding-right: 2ch;
      margin: 0 auto;
      display: block;
      padding-bottom: 0px;
    }
   p, ul, ol {
      margin: 0;
    }
    ul, ol {
      padding-left: 3ch;
    }
  p {
   // text-indent: 3ch;
}
    li p:first-child {
      text-indent: 0;
    }

    #pdf-logo {
      display: none;
    }

   hr {
      margin: 0;
      border-top-color: black;
      margin-top: -0.5px;
      margin-bottom: 27.5px;
    }
  
h1, h2, h3, h4, h5, h6, button { font-size: inherit; line-height: inherit; font-style: inherit; font-weight: inherit; margin: 0; font-feature-settings: "tnum"; border: none; background: transparent; padding: 0;  }
button:focus, button:hover {
  background: rgba(0,0,0,0.125);
  outline: none;
}
h1 {
  font-size: 42px;
  line-height: 56px;
  font-weight: bold;
  margin-top: 14px;
  margin-bottom: 14px;
}
h2 {
  font-size: 31.5px;
  line-height: 42px;
  font-weight: bold;
  margin-top: 28px;
  margin-bottom: 14px;
}
h3 {
  font-size: 26.25px;
  line-height: 35px;
  font-weight: bold;
  margin-top: 14px;
  margin-bottom: 14px;
}
h4 {
  font-size: 21px;
  line-height: 28px;
  font-weight: bold;
  margin-top: 14px;
  margin-bottom: 14px;
}
h5 {
  font-size: 17.5px;
  line-height: 28px;
  margin-top: 14px;
  margin-bottom: 14px;
  font-weight: bold;
}
h6 {
  font-size: 17.5px;
  line-height: 28px;
  margin-top: 14px;
  margin-bottom: 14px;
  font-style: italic;
}
p {
  margin-bottom: 14px;
}
.content {
  position: relative;
  }
figure {
  margin: 0;
  margin-top: 14px;
  margin-bottom: 28px;
  display: block;
  position: relative;
  page-break-inside: avoid;
}
blockquote {
  margin: 0;
   margin-top: 14px;
  margin-bottom: 14px;
margin-left: 2ch;
}
blockquote + blockquote {
  margin-top: 0;
}
figcaption {
  font-family: "Plex Mono", serif, monospace;
  margin-top: 14px;
  font-size: 13.125px;
  line-height: 21px;
}
.info {
  background: #efefef;
  padding-left: 2ch;
  padding-right: 2ch;
  padding-top: 14px;
  padding-bottom: 14px;
  margin-bottom: 28px;
}
.info p:last-child {
  margin-bottom: 0;
}
img {
  display: block;
  position: relative;
  max-width: 100%;
  margin: 0 auto;
  page-break-inside: avoid;
}
code {
  font-size: 0.9em;
  line-height: 1.2;
  background: rgba(0,0,0,0.125);
  padding: 0 0.3em;
}
pre {
  font-size: 0.9em;
  line-height: 1.2;
  background: rgba(0,0,0,0.125);
  overflow-x: scroll;
  max-width: 100%;
  padding-left: 1ch;
  padding-right: 1ch;
  padding-top:0.625em;
  padding-bottom:0.625em;
}
pre code {
  background: transparent;
}

table {
  min-width: 100%;
  text-align: left;
  margin-top: 14px;
  font-size: 13.125px;
  line-height: 18.900000000000002px;
  border-collapse: collapse;
}
table, th, td {
  border: solid 1px black;
}
td {
  padding-left: 0.5ch;
  padding-right: 0.5ch;
  valign: top;
  vertical-align: top;
}
th {
  padding-left: 0.5ch;
  padding-right: 0.5ch;
  vertical-align: top;
  background: #efefef;
}
table ul, table ol {
  list-style-position: inside;
  padding-left: 0;
}

  a {
    color: inherit;
  }
  .table-of-contents {
    background: #efefef;
    position: fixed;
    left: 0;
    top: 0;
    width: 32ch;
    height: 100vh;
    overflow-y: auto;
    background: #efefef;
      // background: rgba(230,230,230,0.85);
      //   backdrop-filter: blur(5px);
  }
  body {
    padding-left: 32ch;
  }
  p:empty {
    display: none;
  }
  ul, ol {
  margin-bottom: 14px;
  }

  #report-iso {
    display: none;
  }

.table-of-contents {
    counter-reset: chapters;
}
 .table-of-contents ul {
    list-style: none;
    padding-left: 0;
    margin-bottom: 0;
  }
 .table-of-contents > ul {
  }
 .table-of-contents > ul > li {
    font-weight: bold;
  }
 .table-of-contents > ul > li {
    font-weight: bold;
   margin-bottom: 14px;
  }

 .table-of-contents > ul > li > ul > li {
    font-weight: normal;
    font-style: normal;
    text-transform: none;
    letter-spacing: 0;
    margin-left: 0;
  }
 .table-of-contents > ul > li > ul > li > ul > li {
    font-weight: normal;
    font-style: italic;
  }
 .table-of-contents a {
    text-decoration: none;
  }
  .table-of-contents a:hover {
    text-decoration: underline;
  }
 sup {
  }
  .table-of-contents ul a {
    display: block;
    padding-left: 24px;
    text-indent: -8px;
    padding-right: 16px;
  }
  .table-of-contents ul li a.active {
    position: relative;
    background: #ddd;
    // text-decoration: line-through;
  }

 .table-of-contents > ul > li > ul > li > a {
    font-size: 15.75px;
      line-height: 25.2px;
    // padding-left: 4ch;
  }
  .table-of-contents > ul > li > ul > li > ul > li > a {
    padding-left: 5ch;
  }

h1 {
    counter-reset: chp;
}
h2 {
  position: relative;
  display: block;
  page-break-before: always;
  padding-top: 28px;
}
  .toc-desktop-hidden .table-of-contents {
    width: auto;
  }
  .toc-desktop-hidden #contents-label {
    display: none;
  }
  .toc-desktop-hidden .table-of-contents ul {
    display: none;
  }
  body.toc-desktop-hidden {
    padding-left: 5ch;
  }
  body:before {
    content: " ";
    height: 28px;
    width: 96ch;
    background: black;
    position: absolute;
    left: 0;
    top: 0;
    z-index: 999;
    display: none;
  }
    #toc-header {
      margin-top: 14px;
      margin-bottom: 14px;
      margin-left: 1ch;
      margin-right: 1ch;
    }

  @media screen and (max-width: 1028px) {
    h1 {
      font-size: 36.75px;
      line-height: 49px;
      font-weight: bold;
      margin-top: 14px;
      margin-bottom: 14px;
    }
    .table-of-contents ul li {
    }

    #toc-header {
      margin-top: 7px;
      margin-bottom: 7px;
    }

    body {
      padding-left: 0;
      padding-top: 42px;
    }
    .content {
        overflow-wrap: break-word;
        word-wrap: break-word;
    }
    #contents-label {
      display: none;
    }
    .table-of-contents {
      height: auto;
      width: 100%;
      z-index: 3;
    }
  body.toc-mobile-show .content:before {
      content: "";
      position: fixed;
      left: 0;
      top: 0;
      bottom: 0;
      right: 0;
      background: rgba(0,0,0,0.25);
      z-index: 2;
      border-top: solid 42px #aaa;
    }

    .table-of-contents > ul {
      display: none;
    }
   body.toc-mobile-show {
      overflow: hidden;
    }
    body.toc-mobile-show #toc-header {
      margin-top: 7px;
      margin-bottom: 7px;
      position: relative;
    }
    body.toc-mobile-show .table-of-contents {
      width: 32ch;
      height: 100vh;
      max-width: calc(100% - 4ch);
      overflow: auto;
    }
   body.toc-mobile-show .table-of-contents > ul {
      display: block;
      padding-bottom: 28px;
      position: relative;
    }
    body.toc-mobile-show #contents-label {
      display: inline;
      position: relative;
    }
  }
}
</style>
<script>
    function inViewport(elem) {
      let bounding = elem.getBoundingClientRect();
      return (
        bounding.top >= 0 &&
        bounding.left >= 0 &&
        bounding.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
        bounding.right <= (window.innerWidth || document.documentElement.clientWidth)
      );
    };

    function setActive(target_id) {
      let selector = '.table-of-contents ul li a[href="#' + target_id + '"]'
      let link = document.querySelector(selector)
      if (link !== null) {
        link.className = 'active'
      }
    }

    window.addEventListener("load", (event) => {
      let headings = document.querySelectorAll('h2, h3');
      let links = document.querySelectorAll('.table-of-contents ul li a')

      observer = new IntersectionObserver((entry, observer) => {
        if (entry[0].intersectionRatio === 1) {
          for (let link of links) {
            link.className = ''
          }
          let target_id = entry[0].target.getAttribute('id')
          setActive(target_id)
        }
      }, { threshold: 1, rootMargin: "0px 0px -50% 0px" });

      let first = true
      for (let heading of headings) {
        if (first && inViewport(heading)) {
          setActive(heading.getAttribute('id'))
          first = false
        }
        observer.observe(heading);
      }

      document.querySelector('#toggle_contents').addEventListener('click', () => {
        let body = document.body
        if (window.innerWidth > 1027) {
          let hidden_class = "toc-desktop-hidden"
          if (body.className === hidden_class) {
            body.className = ''
          } else {
            body.className = hidden_class
          }
        } else {
          let show_class = "toc-mobile-show"
          if (body.className === show_class) {
            body.className = ''
          } else {
            body.className = show_class
          }
        }
      })

      for (let link of links) {
        link.addEventListener('click', (e) => {
          let href = e.target.getAttribute('href')
          let elem = document.getElementById(href.slice(1))
          window.scroll({
            top: elem.offsetTop - 28,
            left: 0,
            behavior: 'smooth'
          })
          if (window.innerWidth < 1028) {
            document.body.className = ''
          }
          e.preventDefault()
        })
      }

      document.querySelector('.content').addEventListener('click', () => {
        if (window.innerWidth < 1028) {
          document.body.className = ''
        }
      })
      document.querySelector('.table-of-contents').addEventListener('click', (e) => {
        e.stopPropagation()
      })

      let mediaQueryList = window.matchMedia("(max-width: 1028px)");
      function handleBreakpoint(mql) {
        // clear any left over toggle classes
        document.body.className = ''
      }
      mediaQueryList.addListener(handleBreakpoint);
    }, false);
  </script>

<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-157475426-14', 'auto');
  ga('send', 'pageview');

  window.addEventListener('load', function() {
    document.getElementById('report-pdf-download').addEventListener('click', function() {
      ga('send', {
        hitType: 'pageview',
        page: '//FF22-Concept_Drift-Cloudera_Fast_Forward.pdf'
      });
    });
  })

</script>
<!-- End Google Analytics -->

<!-- MathJax -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<!-- End MathJax -->

</head>
      <body>
        <div class="content" style="position: relative;">
          <div id="html-logo" style="margin-top: 28px; line-height: 0; display: flex;">
            <a href="https://www.cloudera.com/products/fast-forward-labs-research.html"><img alt="Cloudera Fast Forward Labs" style="display: block; height: 14px; margin-bottom: 7px;" src='/figures/cloudera-fast-forward.png' /></a>
          </div>
          <div id="pdf-logo" style="margin-top: 28px; ">
            <a href="https://www.cloudera.com/products/fast-forward-labs-research.html">Cloudera Fast Forward Labs</a>
          </div>
          <h1 id="inferring-concept-drift-without-labeled-data">Inferring Concept Drift Without Labeled Data</h1>
<p>FF22 · <em>Aug 2021</em></p>
<figure><img src="figures/FF22-cover.png" alt=""></figure>
<p><em>This is an applied research report by <a href="https://www.cloudera.com/products/fast-forward-labs-research.html">Cloudera Fast Forward</a>. We write reports about emerging technologies,
and conduct experiments to explore what’s possible. Read our full report about <em>Inferring Concept Drift Without Labeled Data</em> below, or <a href="/FF22-Concept_Drift-Cloudera_Fast_Forward.pdf" target="_blank" id="report-pdf-download">download the PDF</a>. You can view and download the code accompanying our concept drift experiments <a href="https://github.com/fastforwardlabs/concept-drift">on Github</a>.</em></p>
<p><div class="table-of-contents"><div id="toc-header" style="display: flex; font-weight: bold; text-transform: uppercase;">
     <div><button id="toggle_contents" style="padding-left: 0.5ch; padding-right: 0.5ch; cursor: pointer; position: relative; top: -1px;">☰</button><span id="contents-label" style="margin-left: 0;"> Contents</span></div>
  </div><ul><li><a href="#introduction">Introduction</a></li><li><a href="#background">Background</a><ul><li><a href="#what-is-concept-drift%3F">What is concept drift?</a></li><li><a href="#what-is-a-data-stream%3F">What is a data stream?</a></li></ul></li><li><a href="#framing-the-problem">Framing the problem</a></li><li><a href="#addressing-the-problem">Addressing the problem</a></li><li><a href="#methods-for-inferring-concept-drift">Methods for inferring concept drift</a><ul><li><a href="#1.-statistical-test-for-change-in-feature-space">1. Statistical test for change in feature space</a></li><li><a href="#2.-statistical-test-for-change-in-response-variable">2. Statistical test for change in response variable</a></li><li><a href="#3.-statistical-test-for-change-in-margin-density-of-response-variable">3. Statistical test for change in margin density of response variable</a></li><li><a href="#4.-detect-change-in-margin-density-of-response-distribution-using-a-learned-threshold">4. Detect change in margin density of response distribution using a learned threshold</a></li></ul></li><li><a href="#experiments">Experiments</a><ul><li><a href="#inducing-concept-drift">Inducing concept drift</a></li><li><a href="#experimental-setup">Experimental Setup</a></li><li><a href="#results">Results</a></li><li><a href="#limitations">Limitations</a></li></ul></li><li><a href="#considerations">Considerations</a><ul><li><a href="#ethics">Ethics</a></li><li><a href="#other-prediction-tasks">Other Prediction Tasks</a></li><li><a href="#class-imbalance">Class Imbalance</a></li><li><a href="#active-learning">Active Learning</a></li><li><a href="#semi-supervised-learning">Semi-supervised Learning</a></li><li><a href="#big-data">Big Data</a></li></ul></li><li><a href="#conclusion">Conclusion</a></li></ul></div></p>
<h2 id="introduction">Introduction</h2>
<p>After iterations of development and testing, deploying a well-fit machine learning model often feels like the final hurdle for an eager data science team. In practice, however, a trained model is never final. This milestone marks just the beginning of the perpetual maintenance race that is production machine learning. This is because most machine learning models are static, but the world we live in is dynamic. More specifically, the ability of a trained model to generalize relies on an important assumption of stationarity - meaning the data upon which a model is trained and tested are <em>independent and identically distributed (i.i.d)</em>. In real-world environments, this assumption is often violated, as human behavior - and consequently the systems we aim to model - are dynamically changing all the time.<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<figure><img src="figures/FF22-01.png" alt="Figure 1: Examples of machine learning tasks where the effects of concept drift are prominent"><figcaption>Figure 1: Examples of machine learning tasks where the effects of concept drift are prominent</figcaption></figure>
<p>Take, for instance, the impact of the COVID-19 pandemic on algorithm-driven businesses like inventory management. Instacart’s model for forecasting in-store product availability <a href="https://fortune.com/2020/06/09/instacart-coronavirus-artificial-intelligence/">dropped from 93% to 61% accuracy</a>, due to a drastic change in shopping behavior as consumers stockpiled what previously were infrequently purchased goods. The model was forced to adapt to this transitory shift in its prior understanding of the world.</p>
<p>Not all changes are this sudden, though. Consider the task of maintaining an email spam filtering service. The core technology consists of a text classification model that picks up on keywords in email content to block spammers. Over time, users will begin to manually report more messages as spam that are not caught by the filter. In this adversarial environment, spammers are continuously adjusting terminology to outwit the deployed spam filters, so models must relearn what language constitutes the evolving concept of spam to remain effective.</p>
<p>Think about the job of forecasting energy consumption, in which  historical demand is just one piece of the puzzle. In practice, future demand is driven by a slew of non-stationary forces - like climate fluctuations, population growth, or disruptive clean energy tech - that necessitate both gradual and sudden domain adaptation.</p>
<div class="info">
<p><em><strong>Domain Adaptation</strong></em></p>
<p>Domain adaptation (a subcategory of transfer learning) is the ability to apply an algorithm trained in one or more “source domains” to a different, but related “target domain.” In domain adaptation, the source and target domains share the same feature space, but different distributions.<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
</div>
<p>Changes in environmental conditions like these are referred to as <em>concept drift,</em> and will cause the predictive performance of a model to degrade over time, eventually making it obsolete for the task it was initially intended to solve.</p>
<figure><img src="figures/FF22-02.png" alt="Figure 2: Production model performance will decay over time without adaptation to drifting concepts"><figcaption>Figure 2: Production model performance will decay over time without adaptation to drifting concepts</figcaption></figure>
<p>To combat this divergence between static models and dynamic environments, teams often adopt an adaptive learning strategy that is triggered by the detection of a drifting concept. Supervised drift detection is generally achieved by monitoring a performance metric of interest (such as accuracy) and alerting a retraining pipeline when the metric falls below some designated threshold.</p>
<p>While this strategy proves to be effective in theory, there are several limitations that often prevent its use in practice. Namely, it requires immediate access to an abundance of labels at inference time to quantify a change in system performance - a requirement that may be cost-prohibitive, or even outright impossible, in many real-world machine learning applications.</p>
<p>In this report, we explore broadly applicable approaches for dealing with concept drift when labeled data is <em>not</em> readily accessible. We’ll start by defining what we mean by concept drift and frame the limitations of supervised methods for detecting it. Then, we’ll discuss why true unsupervised concept drift detection is not possible, and explore several alternative methods for dealing with it. Finally, we’ll share the results of our experiments with the proposed methods, and wrap up with a discussion of considerations and limitations.</p>
<h2 id="background">Background</h2>
<h3 id="what-is-concept-drift%3F">What is concept drift?</h3>
<p>Most machine learning systems today operate in a batch paradigm; they probe a historical data set to develop a model that reflects the world as it was at the time of training. But, as we’ve seen, the world is always changing, and the complex relationships that a model abstracts are also likely to change over time - causing model performance to deteriorate, if not accounted for. This phenomenon in which the statistical properties of a target domain change over time is considered concept drift.<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p>
<p>Formally, concept drift between time \(t\) and \(t+1\) can be defined as:</p>
<p>$$P_{t}(X,y) \not= P_{t+1}(X,y)$$</p>
<p>where \(P_t\) denotes the joint probability distribution at time \(t\) between the set of input variables \(X\) and the target variable \(y\). Since the joint probability can be decomposed as the product of the probability of \(X\) and the conditional probability of \(y\) given \(X\), changes in a data stream can therefore be characterized by changes in the components of this relationship according to the equation below.</p>
<p>$$P_t(X,y) = P_t(X) \times P_t(y|X)$$</p>
<p>This decomposition yields two underlying sources of drift - <em>feature drift</em> and <em>real concept drift</em>.</p>
<h5 id="source-1%3A-feature-drift">Source 1: Feature Drift</h5>
<p><em>Feature drift</em> (also referred to as <em>covariate shift, feature change, input drift</em>) characterizes the scenario where the distribution of one or more input variables change over time (i.e., \(P(X)\) changes).</p>
<figure><img src="figures/FF22-03.png" alt="Figure 3: Forms of feature drift. The classification boundary depicted at time (t+1) represents the previously learned relationship between features and targets at time (t). Colors represent ground truth classes of the data points at the specified time step."><figcaption>Figure 3: Forms of feature drift. The classification boundary depicted at time (t+1) represents the <em>previously learned relationship</em> between features and targets at time (t). Colors represent ground truth classes of the data points at the specified time step.</figcaption></figure>
<p>This is seen in both Figure 3.a &amp; 3.b above, where the distribution of features has changed from time \(t\). In Figure 3.a, feature drift has occurred in a region that directly affects the outcome of the learned classification boundary, causing model performance to decrease (and thus making it classified as both feature drift and real concept drift). However, feature drift can also occur where \(P(X)\) changes over time, but the changes do not affect the learned decision boundary. This describes a specific type of feature drift called <em>virtual drift</em>, as seen in Figure 3.b. This is an important distinction because, as we see here, only the changes in \(P(X)\) <em>that affect the prediction decision</em> actually warrant a model adaptation.</p>
<p>For example, consider a clothing brand that is looking to recommend items for a given customer as relevant or not relevant. Suppose this customer lives in a tropical climate. Lightweight, breathable clothing items are relevant to them - while heavy, cold weather apparel is not. In this scenario, the independent features \(X\) are both the customer’s preferences (e.g., age, size, location) and the brand’s product line. The dependent variable, \(y\), is the relevance of a clothing item to the customer.</p>
<p>If the brand’s lead designer quits and is replaced, the brand’s design style will naturally change as a result (i.e., change in \(P(X)\)). However, warm weather clothing still remains relevant for this customer, despite the stylistic differences (i.e., no change in \(P(y|X)\)). This scenario corresponds to a virtual drift.<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p>
<p>Suppose now that, due to a shift in brand strategy, the company alters their product focus to sell mostly cold weather gear and fewer warm weather items, but the designer (and style) stay the same. This scenario also corresponds to a feature drift (Source 1); however, it’s one that does impact the decision boundary (i.e., \(P(y|X)\)). Therefore, this scenario is also categorized as Source 2 drift.</p>
<h5 id="source-2%3A-real-concept-drift">Source 2: Real Concept Drift</h5>
<p>The second source of drift, called <em>real concept drift</em> (also commonly referred to as <em>actual drift, concept shift, conditional change</em>), refers to changes in \(P(y|X)\) and signals that a previously learned relationship between features and targets no longer holds true. Unlike feature drift, this type of drift will <em>always</em> cause a drop in model performance.</p>
<figure><img src="figures/FF22-04.png" alt="Figure 4: Forms of real concept drift. The classification boundary depicted at time (t+1) represents the newly learned relationship between features and targets at time (t+1). Colors represent ground truth classes of the data points at the specified time step."><figcaption>Figure 4: Forms of real concept drift. The classification boundary depicted at time (t+1) represents the <em>newly learned relationship</em> between features and targets at time (t+1). Colors represent ground truth classes of the data points at the specified time step.</figcaption></figure>
<p>It’s important to note that real concept drift can happen either with or without a change in \(P(X)\).<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup> This nuance is shown in Figure 4.a, where both the input feature distributions and the learned decision boundary have changed in the new time step. In contrast, Figure 4.b demonstrates a scenario where input distributions remain constant, while the ground truth class labels have actually evolved.</p>
<p>Continuing with our previous example, suppose that the customer moves from their tropical paradise to the Alaskan tundra, while the clothing brand makes no changes to their offerings or staff. In this case, the very meaning of “relevance” flips, making cold weather gear relevant and warm weather clothing irrelevant. This describes another example of real concept drift, but with no change in \(P(X)\).</p>
<p>However, the real world is rarely ever this clean-cut, and oftentimes both sources of drift are at play simultaneously. Let’s now imagine a situation where the customer moves to a temperate climate with cold nights and warm days, and the company slightly alters their product mix towards cold weather gear. Here, we observe changes in both \(P(X)\) and \(P(y|X)\), making it difficult to attribute concept drift to any single source.</p>
<div class="info">
<p><strong><em>Additional Classifications</em></strong></p>
<p>Both feature drift and real concept drift can be further classified based on the rate at which the concept evolves. For instance, the drift could occur abruptly, resulting in a quick change in the distribution. (Think of drifts induced by a sensor or an equipment failure.) Such cases are considered <em>sudden</em> concept drift. There are other instances where the drift occurs slowly over time - like the drift induced by rising temperatures in the atmosphere. These are deemed <em>gradual</em> concept drift. In addition, there are also <em>recurring</em> concept drifts, which are patterns or trends that tend to repeat themselves at intervals, and are commonly found in seasonal data.</p>
</div>
<h3 id="what-is-a-data-stream%3F">What is a data stream?</h3>
<p>Before moving on, let’s define some additional terminology that will be mentioned throughout this report. To discuss the idea of concept drift in production, we must consider dynamic data environments. For this reason, we reference concept drift detection and adaptation with regard to <em>data streams</em>, where instances arrive continuously and sequentially over time. Streaming data is often generated on the fly - potentially at a fast and variable rate, and with infinite range - making it a prime candidate for evolving data distributions.</p>
<p>Despite this, concept drift is not exclusive to data streams. And, in order to frame a discussion involving both stream and batch contexts, concept drift detection methods commonly employ the notion of <em>sliding windows</em>, or groups of sequentially ordered observations.</p>
<figure><img src="figures/FF22-05.png" alt="Figure 5: Data streams are decomposed into windows of observations to establish context upon which concept drift occurs."><figcaption>Figure 5: Data streams are decomposed into windows of observations to establish context upon which concept drift occurs.</figcaption></figure>
<p>In general, one window contains the instances belonging to the most recent known concept, which were used to train or update the deployed model, and one window contains instances which may have suffered a concept drift. We refer to these windows as the <em>reference window</em> and <em>detection window</em>, respectively.<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup></p>
<h2 id="framing-the-problem">Framing the problem</h2>
<p>With these definitions in mind, we see that real concept drift in a data stream (Source 2) poses the main concern for production models, since it directly impacts model performance. The most effective solution to address this issue involves detecting when the learned relationship between features and targets is no longer appropriate for incoming data, and then training a new model to learn the novel concept. An adaptive workflow like this is shared among common supervised methods like Drift Detection Method (DDM), Early Drift Detection Method (EDDM), and ADaptive WINdowing (ADWIN). We describe this workflow in Figure 6, below.</p>
<figure><img src="figures/FF22-06.png" alt="Figure 6: General workflow of supervised drift detection methods that use significant changes in performance metrics to signal concept drift."><figcaption>Figure 6: General workflow of supervised drift detection methods that use significant changes in performance metrics to signal concept drift.</figcaption></figure>
<p>In general, these techniques monitor a task-dependent performance metric like accuracy, F-score, or precision/recall. If the metric of interest deviates from an acceptable level (as determined during training evaluation on the reference window), a drift is signaled.</p>
<figure><img src="figures/FF22-07.png" alt="Figure 7: Impact of supervised concept drift detection on machine learning system performance over time."><figcaption>Figure 7: Impact of supervised concept drift detection on machine learning system performance over time.</figcaption></figure>
<p>The cumulative effect of this approach over the lifetime of a machine learning system is highlighted in Figure 7. Initially, the system celebrates strong performance because the model has learned from recent data. After some time, accuracy declines as concepts evolve, until ultimately a metric threshold is crossed, and drift is detected. System performance then realizes an immediate boost after retraining, as the new concept is absorbed.</p>
<p>Despite the ample research and proven effectiveness of these supervised methods, they all suffer from a shared, impractical assumption － that true labels are instantaneously available after inference. In most use cases, the immediate availability of true labels is infeasible for several reasons.</p>
<p>First, annotating data is expensive, in both cost and labor, as it often requires hired domain expertise. The issue is described succinctly by the authors of <a href="https://arxiv.org/pdf/1704.00023.pdf">On the Reliable Detection of Concept Drift from Streaming Unlabeled Data</a>:</p>
<blockquote>
<p><em>“To highlight the problem of label dependence, consider the task of detecting hate speech from live tweets, using a classification system facing the Twitter stream (estimated at 500M daily tweets). If 0.5% of the tweets are requested to be labeled, using crowdsourcing websites such as Amazon’s Mechanical Turk2, this would imply a daily expenditure of $50K (each worker paid $1 for 50 tweets), and a continuous availability of 350 crowdsourced workers (assuming each can label 10 tweets per minute, and work for 12 hours/day), every single day, for this particular task alone. The scale and velocity of modern day data applications makes such dependence on labeled data a practical and economic limitation.”</em></p>
</blockquote>
<p>Second, in addition to label scarcity, <em>verification latency</em> - or the period between the availability of an unlabeled test instance and the availability of its true label - is application-dependent and often variable.<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup> For example, it can take several months for an act of credit card fraud to be reported (i.e., ground truth) from the time the fraudulent transaction occurred. If F1 score is the only metric being used to track model performance (and thus detect concept drift), there may be several months of higher than normal fraudulent activity without any signal that something is wrong.</p>
<p>Finally, some use cases operate in an extreme case of <em>infinite verification latency</em>, where ground truth labels are impossible to ever obtain. Consider a bank which uses machine learning to power its lending decisions. If a model predicts a loan will default for a given applicant, the loan is never granted; therefore, it can never be determined if the loan would have actually defaulted or been repaid. Use cases like this demand an alternative solution.</p>
<h2 id="addressing-the-problem">Addressing the problem</h2>
<p>Due to these limitations, there is a clear need for effective methods that can detect real concept drift (Source 2) in an unsupervised manner. Unfortunately, this proves to be an impossible task, as the only way to confirm a change in \(P(y|X)\) with certainty is to have some access to ground truth labels - there is no free lunch.</p>
<p>In the absence of labeled data, the best we can do is attempt to <em>infer</em> real concept drift by detecting feature drift (Source 1). That is, we are interested in quantifying visible changes in \(P(X)\) and surmising that those changes correspond to meaningful change in the classification boundary \(P(y|X)\). Of course, this approach is prone to error because as we’ve seen:</p>
<blockquote>
<ol>
<li>Not all changes in \(P(y|X)\) are visible from \(P(X)\), resulting in false negative detections where real drift occurs but is not signaled.</li>
<li>Not all changes in \(P(X)\) actually affect \(P(y|X)\), resulting in overly sensitive detectors that trigger costly false positive detections.</li>
</ol>
</blockquote>
<p>Inferring real concept drift in an unsupervised fashion thus becomes a delicate balancing act, in order to minimize the number of false positive detections (and therefore labels needed) while remaining sensitive enough to pick up on meaningful changes in the feature space that <em>likely</em> contribute to a change in concept.</p>
<h2 id="methods-for-inferring-concept-drift">Methods for inferring concept drift</h2>
<p>In comparison to recent research on supervised drift detectors, much less attention has been paid to unsupervised methods.<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup> However, detecting shifts in data distributions is a well-explored field of data mining, with solutions ranging from multiple hypothesis testing and novelty detection to discriminative distance and algorithm-specific techniques. In our exploration, we focused on methods that are model-agnostic and truly unsupervised, to ensure broad applicability in practice. In this section, we present four methods for inferring concept drift without labels, and use a binary classification task to frame the discussion.</p>
<h3 id="1.-statistical-test-for-change-in-feature-space">1. Statistical test for change in feature space</h3>
<p>The ultimate goal of feature drift detection is to determine if two distributions are different. Therefore, the first and most basic approach to infer concept drift applies a hypothesis test to flag if a statistically significant change has occurred between the reference and detection windows for each feature in a given data stream.</p>
<p>For continuous features, we use a two-sample <a href="https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test">Kolmogorov-Smirnov (KS)</a> test, which is a non-parametric hypothesis test used to check whether two samples originate from the same distribution. For categorical features, we make use of a <a href="https://en.wikipedia.org/wiki/Chi-squared_test">Chi-Squared</a> goodness of fit test.</p>
<figure><img src="figures/FF22-10.png" alt="Figure 8: Hypothesis tests are performed feature-wise when dealing with multivariate tabular data. Correction is applied to the tests to arrive at overall determination of significance."><figcaption>Figure 8: Hypothesis tests are performed feature-wise when dealing with multivariate tabular data. Correction is applied to the tests to arrive at overall determination of significance.</figcaption></figure>
<p>In the case of multivariate tabular data, we can test each feature independently (while accounting for multiple tests) to arrive at an overall signal of drift or no-drift, as seen in Figure 8. The <a href="https://en.wikipedia.org/wiki/Bonferroni_correction">Bonferroni test</a> is a notable approach for correcting multiple hypothesis tests - while making conservative assumptions about the (in)dependence among them - to arrive at a final result.</p>
<p>In contrast to this feature-wise approach, we could also apply a multivariate two-sample hypothesis test like the kernel-based technique called <a href="https://www.jmlr.org/papers/volume13/gretton12a/gretton12a.pdf">Maximum Mean Discrepancy (MMD)</a>. MMD allows us to distinguish between two probability distributions, based on the mean embeddings of those distributions. While this method does side-step the need for multiple tests, the choice of kernel is critical to ensuring its correctness, and a linear time complexity imposes a potential bottleneck in streaming applications.<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup></p>
<div class="info">
<p><strong><em>High Dimensional Data</em></strong></p>
<p>When it comes to high dimensional data, (e.g., images, text) best practices for detecting drift with two sample tests are an area of active research. Recent work proposes combining dimensionality reduction techniques (e.g., PCA, randomly initialized auto-encoders) with subsequent two-sample testing.<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup> The overall idea is that these dimensionality reduction techniques yield either a uni- or multi-dimensional representation of the data. We can then choose a suitable statistical test to apply to the reduced data stream to detect drift.</p>
</div>
<p>While feature-wise and multivariate hypothesis testing is broadly applicable across machine learning use cases, it has several limitations as a real concept drift inference tool. Because these methods consider drift in each feature to be equally important (despite p-value correction across tests), they are prone to false positive detections. Imagine the case where several features in a datastream exhibit drift, but none of them are of high importance to a classifier’s decision-making process. It’s likely that the present drift will not actually impact the learned decision boundary, despite the hypothesis test’s ringing alarm.</p>
<p>This limitation arises because we’ve excluded the classifier from the detection process and are making decisions solely on the distribution characteristics of incoming features - resulting in increased sensitivity to change and a high number of false alarms.</p>
<h3 id="2.-statistical-test-for-change-in-response-variable">2. Statistical test for change in response variable</h3>
<p>Unlike the previous method, where only the feature space is analyzed, our second approach infers concept drift by tacitly involving the classifier in the detection process, making the change detection process relevant to the prediction task at hand. To do so, we apply a model that’s been trained on the reference window to generate predicted class probabilities (a response distribution) for observations in the detection window. Then, we use a <em>k</em>-fold procedure to obtain probability estimates for the reference window.</p>
<div class="info">
<p><strong><em>K-fold Procedure</em></strong></p>
<p>In the <em>k</em>-fold procedure, the entire dataset is sequentially divided into <em>k</em> bands of samples. In the first iteration, the first <em>k-1</em> bands serve as the training set, to learn a model that is used to generate predictions over the <em>kth</em> band of observations. This process is repeated <em>k</em> times where each band functions as the test set exactly once, yielding a response distribution for the entire reference window.<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup></p>
</div>
<p>With our two populations in hand, we can apply a Kolmogorov-Smirnov hypothesis test to see if the response distributions between reference and detection windows differ significantly. In effect, the trained model serves as a dimensionality-reducing preprocessing step. It leverages its learned relationship between features and targets (i.e., \(P(y|X)\)) to generate a response distribution that is sensitive to feature space changes that will <em>likely</em> affect the performance of the model in question. If important features in the detection window have drifted from those the model learned on, we would expect the classifier to produce significantly different response distributions, as depicted in Figure 9.</p>
<figure><img src="figures/FF22-08.png" alt="Figure 9: Example response distributions between reference and detection windows for a binary classification task. The plot on the left shows nearly identical distributions resulting from a case where feature drift is not present, while the plot on the right depicts divergent distributions."><figcaption>Figure 9: Example response distributions between reference and detection windows for a binary classification task. The plot on the left shows nearly identical distributions resulting from a case where feature drift is not present, while the plot on the right depicts divergent distributions.</figcaption></figure>
<p>Although it’s a step in the right direction, this method is still overly sensitive. That’s because, by design, a KS test is responsive to changes across the <em>entire</em> response distribution. But do we really care about changes in regions of high confidence? For example, if the density shape between 0 and 0.25 confidence level changes a bit, it doesn’t impact the classification outcome of those points, because they’re still well below the 0.5 decision threshold. This leads us to the next approach.</p>
<h3 id="3.-statistical-test-for-change-in-margin-density-of-response-variable">3. Statistical test for change in margin density of response variable</h3>
<p>Rather than test for changes across the entire cumulative response distribution, we can instead focus on just the regions of uncertainty around our decision threshold, where slight variations in confidence lead to different classification outcomes.</p>
<p>To do so, we must introduce a parameter that specifies a desired <em>margin width</em> around the decision boundary, to define a region of uncertainty. Margin here is the portion of the prediction space which is most vulnerable to misclassification.<sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup> Then, for both windows, we classify each observation as <em>in-margin</em> or <em>out-of-margin</em>, based on its predicted confidence score. We compare these categorical populations between windows, using a Chi-square goodness of fit test to check for significant changes in the margin density. The underlying assumption here is that a significant change in the number of samples in the margin is indicative of a drifting concept.</p>
<figure><img src="figures/FF22-09.png" alt="Figure 10: Response distributions that diverge only at tail ends do not impact classification results (left), whereas changes of distribution within the margin do (right). The decision boundary here corresponds to a confidence of 0.5."><figcaption>Figure 10: Response distributions that diverge only at tail ends do not impact classification results (left), whereas changes of distribution within the margin do (right). The decision boundary here corresponds to a confidence of 0.5.</figcaption></figure>
<p>The impact of this approach is highlighted in Figure 10, above. On the left, we see the case where a divergence exists towards the tail ends of the distribution, but the rest of the probability space remains congruent. This example would fail the KS test (described in Method 2), signaling a feature drift, and consequently request costly new labels for retraining. However, because the divergence exists far from the decision boundary, it would <em>likely</em> not have impacted the classification results, making it a false positive detection. In contrast, the margin density approach would tolerate this inconsequential change. Only when a statistically significant divergence occurs <em>inside</em> the margin will Method 3 raise an alarm, as shown in Figure 10 (on the right).</p>
<p>Introducing a margin of uncertainty to desensitize feature drift detection does help reduce the number of false positive detections. However, there is still room for improvement. Each method we have discussed so far relies on hypothesis testing to signal drift; unfortunately, the mere falsity of a null hypothesis doesn’t say much about our window samples, other than that they don’t come from an <em>identical</em> population. But do we really care if the populations are identical?</p>
<p>If our goal is to reduce the sensitivity of feature drift detections, we probably care more about quantifying how different two populations are, which is something that a statistical test cannot provide. A quantitative measure of similarity affords us the flexibility to set our own threshold, depending on our tolerance for error. In essence, we need a way to distinguish what level of change is <em>statistically significant</em> from what is <em>practically significant</em>.</p>
<h3 id="4.-detect-change-in-margin-density-of-response-distribution-using-a-learned-threshold">4. Detect change in margin density of response distribution using a learned threshold</h3>
<p>Our final method uses a learned threshold to detect change in the margin density of a response distribution. Building upon the previous two methods, we first obtain a response distribution for each window ,and introduce a margin to classify predictions as in or out of the region of uncertainty. However, rather than applying a Chi-square test (as in Method 3), we establish an expected value for margin density based on the reference window.</p>
<p>This is accomplished during the <em>k</em>-fold procedure by calculating the percentage of instances falling in margin, relative to the total instances in the window (i.e., margin density) for each fold. The cross-validation procedure produces a population of \(k\) margin density values from which we can calculate a mean (\(MD*{ref}\)) and standard deviation (\(\sigma*{ref}\)), providing a strong estimate of the expected margin density value and an acceptable deviation.</p>
<p>These values are then used to signal change in the detection window based on a desired level of sensitivity, \(S\). A practically significant change is signaled when the margin density of the detection window differs by more than \(S\) standard deviations from the expected margin density value, as seen in the equation below.</p>
<p>$$ |MD*{det} - MD*{ref}| &gt; S \times \sigma_{ref} $$</p>
<p>By setting the expected margin density value from the population observed in the reference window, we establish a baseline specific to the problem at hand. Adding the sensitivity parameter offers control over the detection process. Larger values of \(S\) will reduce the number of false positive detections, but possibly at the cost of increasing false negatives - a decision that might make sense when the cost/impact of a false negative is low. Inversely, lowering \(S\) might be a good idea for critical applications, where the cost of a real drift could be harmful if undetected.<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup></p>
<h2 id="experiments">Experiments</h2>
<p>To gain a deeper understanding of these unsupervised concept drift detection methods, we needed to experiment. In particular, we aimed to understand the tradeoff between false positive and false negative drift detections produced by each of these methods over a ML system’s lifetime. To do so, we designed an experimental setup consisting of an adaptive learning workflow with a synthetic dataset to simulate the lifecycle of a model in production.</p>
<h3 id="inducing-concept-drift">Inducing concept drift</h3>
<p>Experimenting on production-related issues like concept drift is challenging. Concept drift research is often performed on purely synthetic datasets where variables are randomly generated according to predefined rules to allow for control over the type, timing, and magnitude of drift. However, these datasets do not truly mimic the relationships present in real world data. In contrast, real world datasets lack precise flags for the start and end of drifting concepts and often include mixed drift types making it difficult to cleanly evaluate drift detection methods.</p>
<p>For our experimentation, we decided to induce drift into a real dataset as it allowed us to retain genuine data properties while ensuring significant drift is actually present. To do so, we applied an extended version of the drift induction process used by the authors of <a href="https://arxiv.org/pdf/1704.00023.pdf">On the Reliable Detection of Concept Drift from Streaming Unlabeled Data</a> to the <a href="https://archive.ics.uci.edu/ml/datasets/covertype">Covertype Data Set from the UCI Machine Learning Repository</a>​. Before inducing drift, the dataset was reduced to a binary classification problem by considering only the two most populous classes, and all features were normalized in the range of [0,1]. Additionally, all soil type variables were dropped to simplify the problem. This resulted in a dataset with 14 features, one binary target variable, and ~495,000 observations.</p>
<p>The drift induction process works by first shuffling the entire dataset in an attempt to remove any existing concept drift. We then create <em>changepoints</em> in the data stream by selecting a subset of features and randomly rotating their values for all examples after a given changepoint (equivalent of randomly swapping columns). This basic approach ensures that feature drifts are induced while also maintaining the original properties of the dataset. We created three changepoints evenly spaced across the entire dataset. For the first changepoint, we selected the 3 most impactful features to rotate as determined by ranking features based on their impurity-based feature importance. For the second changepoint, we selected the 4th to 10th most important ranked features to rotate. And finally, the remaining three least important features for the third changepoint.  At each changepoint, drift is forward chained through the remainder of the dataset to provide consistency across concepts. This process resulted in four unique “concepts” (~124k observations each) with varying degrees of drift. The entire data preparation and drift induction process can be referenced in <a href="https://github.com/fastforwardlabs/concept-drift/blob/main/notebooks/Covertype_EDA.ipynb">this notebook</a>.</p>
<h3 id="experimental-setup">Experimental Setup</h3>
<p>With a drifting dataset in hand, we then implemented a rudimentary adaptive learning workflow in order to evaluate the proposed detection methods (from above) in a lifecycle context. The workflow consists of two sliding windows (reference and detection) of fixed size passing over the drift induced datastream where the decision to retrain at each timestep is made by the given drift detection method.</p>
<figure><img src="figures/FF22-12.png" alt="Figure 11: The adaptive learning workflow used to evaluate various concept drift detection methods."><figcaption>Figure 11: The adaptive learning workflow used to evaluate various concept drift detection methods.</figcaption></figure>
<p>The workflow described in Figure 11 runs until predictions are generated for every observation in the data set. Throughout each experiment, we record the incremental accuracy of predictions on the datastream, as well as the number of requested true labels. Incremental accuracy provides a cumulative measure of performance of the classification system over the entire datastream since there likely exists several different “deployed” models. The number of requested true labels corresponds directly to the number of drift detections, and thus number of retrainings demanded.</p>
<p>In addition to accuracy and number of retrainings, we also capture if a real concept drift occurred at each window timestep (irrespective of what the drift detection method indicates). Of course, this is a luxury we are only afforded in an experimental setting because we have access to all ground truth labels and it allows us to evaluate our various drift detection methods.  This source of truth is determined using a <em>k</em>-fold approach on the reference window similar to that used in Method 4 above, except rather than gathering a population of k margin density values, we collect a population of accuracy measures to establish an expected accuracy and acceptable deviation. If the accuracy on the detection window falls outside three standard deviations of the expected accuracy, we conclude that a real concept drift occurred (i.e. significant change in \(P(y|X)\)). This approach for quantifying real concept drift (versus just using the three drift induced changepoints) allows us to account for unknown drifts that may exist in the underlying data despite our attempt at removing it via random shuffle. This ground truth indicator serves as the basis for classifying drift detections as false positives or false negatives.</p>
<p>Using this experimental setup, we evaluated detection methods 2, 3, and 4 from above. We compared the results against a baseline and topline scenario. The baseline case is simply a classifier that never adapts to drift (i.e. is trained only on the initial reference window and used to evaluate on the entire remaining datastream). The topline scenario greedily retrains a new model at each window timestep.</p>
<p>All experiments share a common set of parameters including model type (random forest classifier), model hyperparameters (n_estimators=5, max_depth=5) , and window size (35,000 observations). The window size and model hyperparameters were empirically selected by finding a combination that did not result in overfitting between reference and detection sets, while allowing multiple window timesteps to fit within each induced concept. The entire set of experiments and supporting code can be found <a href="https://github.com/fastforwardlabs/concept-drift.git">here</a>.</p>
<h3 id="results">Results</h3>
<p>The cumulative accuracy of each drift detection experiment is visualized and summarized over the full datastream in Figure 12 below. Here, the vertical lines represent the equally spaced changepoints where drift was systematically induced in the datastream.</p>
<figure><img src="figures/FF22-13.png" alt="Figure 12: Summary of experimental results of six drift detection methods used to signal retraining in an adaptive learning simulation. Vertical lines represent the equally spaced changepoints where drift was systematically induced in the datastream. Note that the Topline (orange) and Method 2 (green) experiment lines overlap so only green is visible."><figcaption>Figure 12: Summary of experimental results of six drift detection methods used to signal retraining in an adaptive learning simulation. Vertical lines represent the equally spaced changepoints where drift was systematically induced in the datastream. Note that the Topline (orange) and Method 2 (green) experiment lines overlap so only green is visible.</figcaption></figure>
<p>By observing the baseline case (blue line) where no model retraining occurs after the first window, we see a steep decline in accuracy immediately after the first changepoint. This makes sense because the changepoint introduces a severe drift (i.e. rotation of most important features), and without adaptation, the model fails to reflect the new concepts resulting in a drop of ~18% accuracy from initial training to the end of the data stream.</p>
<p>In contrast, we see that by retraining at each window timestep, the topline case (orange line overlapping with green) is able to recover from each concept change, resulting in a cumulative accuracy drop of just ~2% over the datastream. Of course, this comes at the cost of 13 retrainings (or 99% of the total labels requested) where only 3 actually experienced concept drift. This results in 10 false positives.</p>
<p>As mentioned above, we see that Method 2 (KS test on response distribution) produces identical results to our topline case, meaning the test signals a drift at every window timestep. Intuitively, this does not make sense because there are three distinct windows (of 35,000 records each) within each induced concept. That is, three opportunities for the model to learn and adapt to each new concept. This points to the major flaw of Method 2 - that comparing entire response distributions with a KS test proves to be overly sensitive to small differences that may actually be deemed acceptable in practice (thus prompting a request for unnecessary retraining).</p>
<p>This is further evidenced by observing the results for Method 3 (Chi-squared test on response margin) where only 10 drifts were signaled while still capturing all six actual drift occurrences, but still producing four false positive detections. In this case, by statistically testing for significant changes inside of a defined margin vs. the entire distribution, we required just 77% of the total labels while maintaining a cumulative accuracy within 1% point of the topline case, and did not sacrifice any false negative (missed) detections.</p>
<p>Finally, we see that Method 4 (using a learned threshold of margin density) relaxes drift detections even further. With the sensitivity value set to one, we observe only five drift detections demanding just 42% of the total labels, while producing a cumulative accuracy just 2% points lower than the topline case. However, by stepping away from statistical tests, we notice that this experiment actually misses three windows of actual drift (false negatives). Increasing the sensitivity parameter to a value of two exacerbates this problem, decreasing the cumulative accuracy even further as seven actual drift occurrences are missed.</p>
<h3 id="limitations">Limitations</h3>
<p>As mentioned previously, experimenting with concept drift is challenging because it requires us to simulate a production environment, and make assumptions in an attempt to emulate it. One assumption that we made while designing our dataset is that randomly shuffling all records upfront would eliminate existing drift and provide a clean slate upon which we could introduce controlled drift. This false assumption is brought to light where we see more than 3 actual drift occurrences in several of the experiments. Because we chose to define real drifts by comparing change in accuracy between reference and detection windows, we see an unequal number of “actual drifts” across experiments, making head-to-head comparison of results difficult.</p>
<p>Additionally, we chose to implement non-overlapping, fixed-size windows that advance in full for all experiments. Many drift detection methods today operate in an incremental or online fashion where detection windows are advanced for each incoming observation rather than batches. This strategy eliminates the period of inactivity until a new detection window reaches the minimum number of samples and may decrease the delay in response time for sudden drift detections.</p>
<p>Another limitation is seen in our rudimentary retraining scheme where labels are requested for the entire detection window upon a drift signal and the existing model architecture is retrained in place. In practice, there are a variety of retraining options like using all available historical data, weighting newer observations, dropping outdated records, or requesting just a portion of labels from the newest window. In addition, naive retraining of the same model with new data might not be enough to adapt to an evolved concept.<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup> A manually selected model architecture may perform better upon each retraining which points to another limiting assumption of our experimental setup.</p>
<h2 id="considerations">Considerations</h2>
<p>So far we have discussed and experimented with approaches for dealing with concept drift when the ground truth of the newly available data instances isn’t readily available. While we covered methods that are model agnostic and truly unsupervised, detecting concept drift in practice is not a straightforward task. As noted by the researchers of <a href="https://arxiv.org/pdf/2004.05785.pdf">Learning under Concept Drift: A Review</a>, handling concept drift is generally coupled with other ML problems. In this section, we cover a few of these overlapping issues along with some considerations when designing a drift detection strategy.</p>
<h3 id="ethics">Ethics</h3>
<p>It’s impossible to design a machine learning system knowing everything about the domain upfront. As we’ve seen, concept drift occurs by default as a result of static models operating in dynamic environments. And therefore, deployed models will naturally have unintended consequences. For this reason, it’s imperative that teams plan for uncertainty post-deployment and have robust monitoring and detection processes established to understand when something has gone wrong and take corrective action.</p>
<p>However, the act of monitoring a feature or metric just to “check the box” is not enough. Blindly optimizing and maintaining a poorly selected set of metrics results in far from optimal outcomes. This is because metric optimization often leads to manipulation, gaming, and a focus on short-term quantities at the expense of longer-term concerns. When developing a post-production strategy, it’s important to use a slate of metrics to gain a fuller picture of a model’s true impact, combine metrics with qualitative accounts, and involve a range of stakeholders including those who will be impacted downstream by the model’s decisions.<sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup> Planning for and monitoring a model’s impact on a wider set of concerns than just predictive performance adds an additional layer of complexity to the already difficult task of production machine learning. But it’s a requirement, not an option.</p>
<h3 id="other-prediction-tasks">Other Prediction Tasks</h3>
<p>Up until now, all of the methods discussed for inferring drift have been in the context of binary classification. But how can these approaches be extended to other tasks like multiclass classification and regression? At the core of our approaches, we are simply using a trained model to produce a distribution of uncertainty and then comparing that distribution between reference and detection windows. Therefore, we can apply this same idea to other tasks by reformulating our definition of uncertainty. In the binary classification task, uncertainty exists as the difference between the two class probabilities. In a multiclass classification task, uncertainty could be defined as the difference between the top two class probabilities. Similarly for regression tasks, the notion of uncertainty could take the form of absolute error of each prediction.</p>
<h3 id="class-imbalance">Class Imbalance</h3>
<p>The common issue of class-imbalance is exacerbated when it comes to drift detection. Class imbalance occurs when the proportion of data instances belonging to each class varies, causing certain classes to be underrepresented. It is usually the underrepresented classes in such situations that end up having higher misclassifications. Detecting drift between populations with imbalanced classes is complicated, and becomes more challenging when the data between windows cannot be stored due to memory issues. As such, approaches that cater to both concept drift and class imbalance in data streams are relatively less studied.<sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup> That said, CDS (Concept Drift with SMOTE (Synthetic Minority class Oversampling Technique)) is one of the more recent batch-based incremental learning algorithms that strategically uses the minority class data to tackle this problem.<sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup></p>
<p>Another related problem that is largely under-explored is dealing with multi-label classification where a particular data instance could be associated with one or more labels. For example, a news article may have overlapping classes like “politics”, “environment” and “energy”. Multi-label data streams contain independent relationships for each label where each concept is likely to have its own drift pattern that may drift asynchronously from its peers. In addition, label proportions may not be consistent across detection windows. To deal with these challenges a notable approach<sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup> associates each label with two fixed size instance-windows, one for positive and the other for negative examples for the training data. The size of the positive window is a user-specified parameter, and it should be large enough to learn an accurate model, but small enough to reduce the probability of drift within the window. The number of negative examples in the negative window is determined based on the ratio of the number of positive examples to another user-specified parameter －distribution ratio. This parameter plays the role of balancing the distribution of positive and negative examples in the union of the two windows and ranges typically from 0.3 to 0.7. The approach allows it to oversample the positive and undersample the negative examples for all labels. They further build and use k-nearest neighbor (k-NN) classifiers to determine the label of an unlabeled test instance. Normally a k-NN classifier outputs a class label based on whether the probability of it belonging to the positive class is &gt;= 0.5. This default behavior is an improper choice when it comes to imbalanced classes and the authors instead propose a batch specific thresholding approach to combat that.</p>
<h3 id="active-learning">Active Learning</h3>
<p>Active learning is a set of machine learning techniques that reduces the number of labeled examples required to train a model. In settings where the labeled examples are available only initially or are scarce, active learning approaches utilize these labels to build an initial model, and then uses this model to request labels for data points from a human that the model finds hard to predict on. A scenario where the unlabeled data stream is drifting could pose additional challenges. For instance, active learning strategies that request labels for the most uncertain instances would typically concentrate around the decision boundary. Changes that occur further from the boundary may be missed, and models may fail to adapt. Some solutions to effectively tackle such challenges include learning strategies that are guided by drift detection to save labeling costs for difﬁcult and evolving instances.<sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup><sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup></p>
<h3 id="semi-supervised-learning">Semi-supervised Learning</h3>
<p>Semi-supervised and transductive learning techniques leverage both labeled and unlabeled examples to learn more generalized models when limited labeled data is available for training. Because this technique naturally learns from unlabeled data, it may be assumed that models of this type can easily track drifting concepts. However, that’s not the case because with concept drift, training data and test data are generated from different underlying distributions. Due to this unique learning paradigm, there have been many new developments specific to semi-supervised and transductive learning in the presence of concept drift. For instance, the weight estimation algorithm (an ensemble-based classifier approach<sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup>) uses unlabeled test data along with a set of mixture models to adjust classifier voting weights. The approach helps detect gradual or incremental drifts. There is also the COMPOSE (COMPacted Object Sample Extraction) approach that can handle multi-class data, including the scenario of new classes or new subpopulations for gradual drift detection.<sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup>)</p>
<h3 id="big-data">Big Data</h3>
<p>Data in big data streaming environments is often generated at a fast rate, in large quantities, and is highly volatile - a scenario prime for drifting concepts. Due to the high throughput nature, it may not always be feasible to capture, store, and process all the data. This complication has led to the development of scalable and parallel algorithmic implementations that only need one pass through the data, and thus train and adapt to concept drifts in real-time scenarios. For instance, the Online MapReduce Drift Detection Method (OMR-DDM)<sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup>) detects drift by the use of the error rate of a collection of classifiers executed concurrently. Approaches like Micro-Cluster Nearest Neighbor (MC-NN)<sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup>) do not need data to reside in memory, are processed incrementally and adapt to concept drifts by monitoring classification error.</p>
<h2 id="conclusion">Conclusion</h2>
<p>As we’ve learned, maintaining a static representation of an ever-changing environment is challenging, and requires diligent performance monitoring to signal when a machine learning model is no longer suited for its original job. This issue becomes even harder when the cost or availability of ground truth labels make performance-based drift detection methods infeasible － which is often the case in real world applications.</p>
<p>In this scenario, teams must monitor and detect changes purely from independent variables as a means to infer concept drift. Unfortunately, monitoring changes in input distributions produces many false positive detections because not all changes in the feature space of a population actually correspond to a meaningful drift in relation to the target variable.</p>
<p>In this report, we presented four ways to infer concept drift in an unsupervised manner with the goal of reducing false positive drift detections. We reported experimental results comparing and contrasting the nuances of each method and conclude that the best approach for detecting drift without labels will depend on your specific application’s tolerance for error. We hope this report has brought to light a few practical challenges associated with production machine learning and we look forward to continued research in this space!</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://arxiv.org/pdf/1704.00023.pdf">On the Reliable Detection of Concept Drift from Streaming Unlabeled Data</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="https://en.wikipedia.org/wiki/Domain_adaptation">Domain adaptation</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="https://arxiv.org/pdf/2004.05785.pdf">Learning under Concept Drift: A Review</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p><a href="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/82cb2dbe-86a2-43d0-8ac2-fb2892295b48/A_Survey_on_Concept_Drift_Adaptation_2014.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210804%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20210804T123525Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=0e75f52b14a5448db13ddefc0c1825b9df11a4fab6577f10d632ae64bf317373&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22A%2520Survey%2520on%2520Concept%2520Drift%2520Adaptation%25202014.pdf%22">A Survey on Concept Drift Adaptation</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p><a href="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/82cb2dbe-86a2-43d0-8ac2-fb2892295b48/A_Survey_on_Concept_Drift_Adaptation_2014.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210804%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20210804T123525Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=0e75f52b14a5448db13ddefc0c1825b9df11a4fab6577f10d632ae64bf317373&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22A%2520Survey%2520on%2520Concept%2520Drift%2520Adaptation%25202014.pdf%22">A Survey on Concept Drift Adaptation</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p><a href="https://wires.onlinelibrary.wiley.com/doi/full/10.1002/widm.1381">An overview of unsupervised drift detection methods</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p><a href="https://www.kdd.org/kdd2016/papers/files/rpp0427-dos-reisA.pdf">Fast Unsupervised Online Drift Detection Using Incremental Kolmogorov-Smirnov Test</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p><a href="https://wires.onlinelibrary.wiley.com/doi/full/10.1002/widm.1381">An overview of unsupervised drift detection methods</a> <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p><a href="http://www.stat.cmu.edu/~siva/Papers/MMD12.pdf">Optimal kernel choice for large-scale two-sample tests</a> <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p><a href="https://arxiv.org/abs/1810.11953?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%253A+arxiv%252FQSXk+%2528ExcitingAds%2521+cs+updates+on+arXiv.org%2529">Failing Loudly: An Empirical Study of Methods for Detecting Dataset Shift</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p><a href="https://arxiv.org/pdf/1704.00023.pdf">On the Reliable Detection of Concept Drift from Streaming Unlabeled Data</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p><a href="https://arxiv.org/pdf/1704.00023.pdf">On the Reliable Detection of Concept Drift from Streaming Unlabeled Data</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p><a href="https://arxiv.org/pdf/1704.00023.pdf">On the Reliable Detection of Concept Drift from Streaming Unlabeled Data</a> <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p><a href="https://evidentlyai.com/blog/machine-learning-monitoring-data-and-concept-drift">Machine Learning Monitoring, Part 5: Why You Should Care About Data and Concept Drift</a> <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p><a href="https://arxiv.org/pdf/2002.08512.pdf">Reliance on Metrics is a Fundamental Challenge for AI</a> <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p><a href="https://www.sciencedirect.com/science/article/abs/pii/S095070512030126X">Incremental learning imbalanced data streams with concept drift: The dynamic updated ensemble algorithm</a> <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p><a href="https://ieeexplore.ieee.org/document/6235959">Incremental Learning of Concept Drift from Streaming Imbalanced Data</a> <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p><a href="https://www.ijcai.org/Proceedings/11/Papers/266.pdf">Dealing with Concept Drift and Class Imbalance in Multi-Label Stream Classification</a> <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p><a href="https://ieeexplore.ieee.org/document/6414645">Active Learning With Drifting Streaming Data</a> <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p><a href="https://www.researchgate.net/publication/330629277_Combining_active_learning_with_concept_drift_detection_for_data_stream_mining">Combining active learning with concept drift detection for data stream mining</a> <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p><a href="http://users.rowan.edu/~polikar/RESEARCH/PUBLICATIONS/ijcnn11.pdf">Semi-supervised Learning in Nonstationary Environments</a> <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p><a href="https://www.researchgate.net/publication/260354243_COMPOSE_A_Semisupervised_Learning_Framework_for_Initially_Labeled_Nonstationary_Streaming_Data">COMPOSE: A Semisupervised Learning Framework for Initially Labeled Nonstationary Streaming Data</a> <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p><a href="https://ieeexplore.ieee.org/document/6406468">Parallel Concept Drift Detection with Online Map-Reduce</a> <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p><a href="https://www.sciencedirect.com/science/article/pii/S0167739X17304685">Scalable real-time classification of data streams with concept drift</a> <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

        </div>
      </body>
   </html>
  